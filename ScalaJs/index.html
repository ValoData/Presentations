<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/gris.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body class="default">
		<div class="reveal">
			<div class="slides">
				<section body class="home">
					<p>
					<object data="your.svg" type="image/svg+xml">
  					<img class="plain" width="300px" src="images/valodata_logo.svg"  />
					</object>
					</p>
					<h1 id="scala-workshop">Scala 2.0 Workshop</h1>
					<h3 id="email">ulrich@valodata.com - @valodata</h3>
					
				</section>
				<section>
					<h2 id="agenda">Agenda</h2>
					<ol> 
					<strong><li>Scala</li>
					<li>Spark</li>
					<li>RDD Operations</li>
					<li>Spark SQL</li>
					<li>Machine Learning</li>
					<li>Data Visualisation</li>
					<li>Self Contained Applications</li>
					</strong>					
					</ol>

				</section>

				<section>
					<h1 id="scala-for-spark">Scala for Spark</h1>
				</section>
				
				<section>
					<h2 id="building-blocks">Building blocks</h2>
					<ul>
						<li>Data</li>
						<li>Expressions</li>
						<li>Functions</li>
						<li>Collections</li>
					</ul>
				</section>


				
				<section>

					<section>
						<h2 id="data">Data</h2>
							<ul>
								<li>Literals, Values, Variables, Types and Naming </li>
							</ul>
					</section>
					<section>
					<h2 id="data_1">Data</h2> 
					<p>Numeric Types:</p>

					<table>
						<thead>
						<tr>
						<th>Name</th>
						<th>Description</th>
						<th>Size</th>
						<th>Min</th>
						<th>Max</th>
						</tr>
						</thead>
						<tbody>
						<tr>
						<td>Byte</td>
						<td>Signed integer</td>
						<td>1byte</td>
						<td>–127</td>
						<td>128</td>
						</tr>
						<tr>
						<td>Short</td>
						<td>Signed integer</td>
						<td>2bytes</td>
						<td>–32768</td>
						<td>32767</td>
						</tr>
						<tr>
						<td>Int</td>
						<td>Signed integer</td>
						<td>4bytes</td>
						<td>–2<sup>31</sup></td>
						<td>2<sup>31</sup>–1</td>
						</tr>
						<tr>
						<td>Long</td>
						<td>Signed integer</td>
						<td>8bytes</td>
						<td>2<sup>63</sup></td>
						<td>2<sup>63</sup>–1</td>
						</tr>
						<tr>
						<td>Float</td>
						<td>Signed floating point</td>
						<td>4bytes</td>
						<td>n/a</td>
						<td>n/a</td>
						</tr>
						<tr>
						<td>Double</td>
						<td>Signed floating point</td>
						<td>8bytes</td>
						<td>n/a</td>
						<td>n/a</td>
						</tr>
						</tbody>
					</table>

					</section>


					<section>
						<h2 id="data_1">Data</h2> 
						<p>Nonnumeric Types Instantiables:</p>
						<table>
							<thead>
							<tr>
							<th>Name</th>
							<th>Description</th>
							</tr>
							</thead>
							<tbody>
							<tr>
							<td>Char</td>
							<td>Unicode character</td>
							</tr>
							<tr>
							<td>Boolean</td>
							<td>true or false</td>
							</tr>
							<tr>
							<td>String</td>
							<td>A string of characters (i.e., text)</td>
							</tr>
							</tbody>
						</table>
					</section>

				
					<section>
						<h2 id="data_1">Data</h2> 
						<p>Nonnumeric Types Non-Instantiables:</p>
						<table>
							<thead>
							<tr>
							<th>Name</th>
							<th>Description</th>
							</tr>
							</thead>
							<tbody>
							<tr>
							<td>Any</td>
							<td>The root of all types in Scala</td>
							</tr>
							<tr>
							<td>AnyVal</td>
							<td>The root of all value types</td>
							</tr>
							<tr>
							<td>AnyRef</td>
							<td>The root of all reference (nonvalue) types</td>
							</tr>
							<tr>
							<td>Nothing</td>
							<td>The subclass of all types</td>
							</tr>
							<tr>
							<td>Null</td>
							<td>The subclass of all AnyRef types signifying a null value</td>
							</tr>
							<tr>
							<td>Unit</td>
							<td>Denotes the lack of a value</td>
							</tr>
							</tbody>
						</table>
					</section>

					<section>
						<h2 id="data_1">Data</h2> 
						<p>Data Types Summary:</p>
						<p><img alt="" src="./images/dataTypes.png" /> </p>
					</section>
					
					<section>
						<h2 id="data_1">Data</h2> 
						<p><strong>Naming:</strong></p>
						<p style="text-align: left" >Scala names can use letters, numbers, and a range of special operator characters. <br />
This makes it possible to use standard mathematical operators (e.g., * and :+ ) and constants (e.g., π and φ ) in place of longer names to make the code more expressive.</p>
<p><strong>Camel Case Convention:</strong><br/></p>
<p style="text-align: left">
- Value and variable names -&gt; start with a lowercase letter and then capitalize additional words. <br />
- Types and classes follow camel case but start with an uppercase letter.</p>
					</section>

					<section>
						<p>Exercise:</p>
						<p> Using the formula (x*9/5)+32 </p>
						<p> Find the temperature in Farenheit </p>
					</section>
					<section>
						<p> Using the formula (x*9/5)+32 </p>
						<p> Find the temperature in Farenheit </p>
						<p>Solution:</p>
  						<pre><code>val tempCel = 24
val tepmFar = (tempCel*9/5)+32</code></pre>
					</section>
						
				
				</section>

				<section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Definition:</strong> A single unit of code that returns a value:</p>
						<pre><code>scala> "hello"
res0: String = hello

scala> "hel" + 'l' + "o"
res1: String = hello</code></pre>
						<p><strong>Syntax:</strong> Defining Values and Variables, Using Expressions:<p>
						<pre><code>
val <identifier>[: <type>] = <expression>
var <identifier>[: <type>] = <expression></code></pre>								

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Blocks:</strong></p>
						<pre><code>scala> val x = 5 * 20; val amount = x + 10
x: Int = 100
amount: Int = 110</code></pre>
						<pre><code>scala> val amount = { val x = 5 * 20; x + 10 }
amount: Int = 110</code></pre>		
						<p>Or accross several lines:</p>
						<pre><code>scala> val amount = {
		    val x = 5 * 20
		    x + 10
		    }
amount: Int = 110</code></pre>								

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>If...Else expression:</strong></p>
						<p><strong>Syntax:</strong></p>
						<pre><code>if (<Boolean expression>) <expression>
else <expression></code></pre>
						<p><strong>Example:</strong></p>
						<pre><code>scala> val x = 10; val y = 20
x: Int = 10
y: Int = 20
scala> val max = if (x > y) x else y
max: Int = 20</code></pre>
									

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Match expression:</strong></p>
						<p><strong>Syntax:</strong></p>
						<pre><code><expression> match {
case <pattern match> => <expression>
[case...]
}</code></pre>
						<p><strong>Example:</strong></p>
						<pre><code>scala> val x = 10; val y = 20
x: Int = 10
y: Int = 20
scala> val max = x > y match {
case true => x
case false => y
 }
max: Int = 20</code></pre>
									

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Loops:</strong></p>
						<p><strong>Syntax:</strong></p>
						<pre><code><expression> for (<identifier> <- <iterator>) [yield] [<expression>]</code></pre>
						<p><strong>Example:</strong></p>
						<pre><code> scala> val threes = for (i <- 1 to 20 if i % 3 == 0) yield i
threes: scala.collection.immutable.IndexedSeq[Int] = Vector(3, 6, 9, 12, 15, 18) </code></pre>
									

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Exercise:</strong></p>
						<p style="text-align: left">Given a double <strong >amount</strong > , write an expression to return “greater” if it is more than zero, “same” if it equals zero, and “less” if it is less than zero. Can you write this with if..else blocks? How about with match expressions?</p>
					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Exercise: Solution</strong></p>
						<p style="text-align: left">Given a double <strong >amount</strong > , write an expression to return “greater” if it is more than zero, “same” if it equals zero, and “less” if it is less than zero. Can you write this with if..else blocks? How about with match expressions?</p>
						<pre><code>val amount = 1.1
val valToZero = {if (amount > 0) "greater"
		else if (amount < 0) "less"
		else "same"}</code></pre> 						
					</section>
				</section>
				<section>
					<section>
					<h2 id="functions">Functions</h2>
					<li style="text-align: left"><strong>Functional programming languages</strong> are geared to support the creation of highly reusable and composable functions.</li>
					<li style="text-align: left">A simple function (e.g., to double a number) may be picked up and applied
across a 50,000-node list, or given to an actor to be executed either locally or in a remote server.</li>
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p><strong>Syntax:</strong> </p>
					<pre><code> def <identifier>(<identifier>: <type>[, ... ]): <type> = <expression> </code></pre>
					<p><strong>Example:</strong> Function that performs an multiplication</p>
					<pre><code> scala> def multiplier(x: Int, y: Int): Int = { x * y }
multiplier: (x: Int, y: Int)Int
scala> multiplier(6, 7)
res0: Int = 42 </code></pre>
					
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p><strong>Recursive Functions:</strong> </p>
					<p style="text-align: left" ><strong>Definition:</strong> A function that may invoke itself, preferably with some type of parameter or external condition that will be checked to avoid an infinite loop</p>
					<p style="text-align: left" ><strong>Example:</strong> A recursive function that raises an integer by a given positive exponent:</p>
					<pre><code> scala> def power(x: Int, n: Int): Long = {
if (n >= 1) x * power(x, n-1)
else 1
}
power: (x: Int, n: Int)Long
scala> power(2, 8)
res6: Long = 256</code></pre>
					
					</section>
					<section>
						<h2 id="functions">Functions</h2>					
						<p><strong>Exercise:</strong></p>
						<p style="text-align: left">Write a function that computes the area of a circle given its radius.</p>
					</section>
					<section>
						<h2 id="functions">Functions</h2>					
						<p><strong>Exercise: Solution</strong></p>
						<p style="text-align: left">Write a function that computes the area of a circle given its radius.</p>
						<pre><code>def area(r:Double) = 2*3.14*r</code></pre> 						
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p><strong>Partially Applied Functions and Currying</strong> </p>
					<p>Example of Partialy Applied Function </p>
					<pre><code>scala> def factorOf(x: Int, y: Int) = y % x == 0
factorOf: (x: Int, y: Int)Boolean</code></pre>
					<pre><code>scala> val multipleOf3 = factorOf(3, _: Int)
multipleOf3: Int => Boolean = <function1>
scala> val y = multipleOf3(78)
y: Boolean = true</code></pre>
					<p>Example of Currying</p>
<p>Instead of breaking up a parameter list into applied and unapplied parameters, apply the parameters for one list while leaving another list unapplied.</p>
					<pre>val f = factorOf _
scala> val multipleOf3 = factorOf(3) _
multipleOf3: Int => Boolean = <function1>
scala> val z = multipleOf3(78)
z: Boolean = true<code></code></pre>
					
					</section>


				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
