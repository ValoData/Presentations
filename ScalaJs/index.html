<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/gris.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body class="default">
		<div class="reveal">
			<div class="slides">
				<section body class="home">
					<p>
					<object data="your.svg" type="image/svg+xml">
  					<img class="plain" width="300px" src="images/valodata_logo.svg"  />
					</object>
					</p>
					<h1 id="scala-workshop">Scala 2.0 Workshop</h1>
					<h3 id="email">ulrich@valodata.com - @valodata</h3>
					
				</section>
				<section>
					<h2 id="agenda">Agenda</h2>
					<ol> 
					<strong><li>Scala</li>
					<li>Spark</li>
					<li>RDD Operations</li>
					<li>Spark SQL</li>
					<li>Machine Learning</li>
					<li>Data Visualisation</li>
					<li>Self Contained Applications</li>
					</strong>					
					</ol>

				</section>

				<section>
					<h1 id="scala-for-spark">Scala for Spark</h1>
				</section>
				
				<section>
					<h2 id="building-blocks">Building blocks</h2>
					<ul>
						<li>Data</li>
						<li>Expressions</li>
						<li>Functions</li>
						<li>Collections</li>
					</ul>
				</section>


				
				<section>

					<section>
						<h2 id="data">Data</h2>
							<ul>
								<li>Literals, Values, Variables, Types and Naming </li>
							</ul>
					</section>
					<section>
					<h2 id="data_1">Data</h2> 
					<p>Numeric Types:</p>

					<table>
						<thead>
						<tr>
						<th>Name</th>
						<th>Description</th>
						<th>Size</th>
						<th>Min</th>
						<th>Max</th>
						</tr>
						</thead>
						<tbody>
						<tr>
						<td>Byte</td>
						<td>Signed integer</td>
						<td>1byte</td>
						<td>–127</td>
						<td>128</td>
						</tr>
						<tr>
						<td>Short</td>
						<td>Signed integer</td>
						<td>2bytes</td>
						<td>–32768</td>
						<td>32767</td>
						</tr>
						<tr>
						<td>Int</td>
						<td>Signed integer</td>
						<td>4bytes</td>
						<td>–2<sup>31</sup></td>
						<td>2<sup>31</sup>–1</td>
						</tr>
						<tr>
						<td>Long</td>
						<td>Signed integer</td>
						<td>8bytes</td>
						<td>2<sup>63</sup></td>
						<td>2<sup>63</sup>–1</td>
						</tr>
						<tr>
						<td>Float</td>
						<td>Signed floating point</td>
						<td>4bytes</td>
						<td>n/a</td>
						<td>n/a</td>
						</tr>
						<tr>
						<td>Double</td>
						<td>Signed floating point</td>
						<td>8bytes</td>
						<td>n/a</td>
						<td>n/a</td>
						</tr>
						</tbody>
					</table>

					</section>


					<section>
						<h2 id="data_1">Data</h2> 
						<p>Nonnumeric Types Instantiables:</p>
						<table>
							<thead>
							<tr>
							<th>Name</th>
							<th>Description</th>
							</tr>
							</thead>
							<tbody>
							<tr>
							<td>Char</td>
							<td>Unicode character</td>
							</tr>
							<tr>
							<td>Boolean</td>
							<td>true or false</td>
							</tr>
							<tr>
							<td>String</td>
							<td>A string of characters (i.e., text)</td>
							</tr>
							</tbody>
						</table>
					</section>

				
					<section>
						<h2 id="data_1">Data</h2> 
						<p>Nonnumeric Types Non-Instantiables:</p>
						<table>
							<thead>
							<tr>
							<th>Name</th>
							<th>Description</th>
							</tr>
							</thead>
							<tbody>
							<tr>
							<td>Any</td>
							<td>The root of all types in Scala</td>
							</tr>
							<tr>
							<td>AnyVal</td>
							<td>The root of all value types</td>
							</tr>
							<tr>
							<td>AnyRef</td>
							<td>The root of all reference (nonvalue) types</td>
							</tr>
							<tr>
							<td>Nothing</td>
							<td>The subclass of all types</td>
							</tr>
							<tr>
							<td>Null</td>
							<td>The subclass of all AnyRef types signifying a null value</td>
							</tr>
							<tr>
							<td>Unit</td>
							<td>Denotes the lack of a value</td>
							</tr>
							</tbody>
						</table>
					</section>

					<section>
						<h2 id="data_1">Data</h2> 
						<p>Data Types Summary:</p>
						<p><img alt="" src="./images/dataTypes.png" /> </p>
					</section>
					
					<section>
						<h2 id="data_1">Data</h2> 
						<p><strong>Naming:</strong></p>
						<p style="text-align: left" >Scala names can use letters, numbers, and a range of special operator characters. <br />
This makes it possible to use standard mathematical operators (e.g., * and :+ ) and constants (e.g., π and φ ) in place of longer names to make the code more expressive.</p>
<p><strong>Camel Case Convention:</strong><br/></p>
<p style="text-align: left">
- Value and variable names -&gt; start with a lowercase letter and then capitalize additional words. <br />
- Types and classes follow camel case but start with an uppercase letter.</p>
					</section>

					<section>
						<p>Exercise:</p>
						<p> Using the formula (x*9/5)+32 </p>
						<p> Find the temperature in Farenheit </p>
					</section>
					<section>
						<p> Using the formula (x*9/5)+32 </p>
						<p> Find the temperature in Farenheit </p>
						<p>Solution:</p>
  						<pre><code class="scala">scala> val celcius = 24
scala> val farenheit = (celcius*9/5)+32
farenheit: Int = 75
</code></pre>
					</section>
						
				
				</section>

				<section>
					<section>
					
						<h2 id="expression">Expressions</h2>					
						<p><strong>Definition:</strong> A single unit of code that returns a value:</p>
						<pre><code class="scala">scala> "hello"
res0: String = hello

scala> "hel" + 'l' + "o"
res1: String = hello</code></pre>
						<p><strong>Syntax:</strong> Defining Values and Variables, Using Expressions:<p>						
						<pre><code class="scala">val &lt;identifier&gt;[: &lt;type&gt;] = &lt;expression&gt;
var &lt;identifier&gt;[: &lt;type&gt;] = &lt;expression&gt;</code></pre>							

					</section>

					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Blocks:</strong></p>
						<pre><code class="scala">scala> val x = 5 * 20; val amount = x + 10
x: Int = 100
amount: Int = 110</code></pre>
						<pre><code class="scala">scala> val amount = { val x = 5 * 20; x + 10 }
amount: Int = 110</code></pre>		
						<p>Or accross several lines:</p>
						<pre><code class="scala">scala> val amount = {
		    val x = 5 * 20
		    x + 10
		    }
amount: Int = 110</code></pre>								

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>If...Else expression:</strong></p>
						<p><strong>Syntax:</strong></p>
						<pre><code class="scala">if ( &lt;boolean expression=""&gt;)  &lt;expression&gt;
else  &lt;expression&gt;</code></pre>
						<p><strong>Example:</strong></p>
						<pre><code class="scala">scala> val x = 10; val y = 20
x: Int = 10
y: Int = 20
scala> val max = if (x > y) x else y
max: Int = 20</code></pre>
									

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Match expression:</strong></p>
						<p><strong>Syntax:</strong></p>
						<pre><code class="scala">&lt;expression&gt; match {
case &lt;pattern match=""&gt; =&gt; &lt;expression&gt;
[case...]
}</code></pre>
						<p><strong>Example:</strong></p>
						<pre><code class="scala">scala> val x = 10; val y = 20
x: Int = 10
y: Int = 20
scala> val max = x > y match {
case true => x
case false => y
 }
max: Int = 20</code></pre>
									

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Loops:</strong></p>
						<p><strong>Syntax:</strong></p>
						<pre><code class="scala">&lt;expression&gt; for (&lt;identifier&gt; <- &lt;iterator&gt;) [yield] [&lt;expression&gt;]
</code></pre>
						<p><strong>Example:</strong></p>
						<pre><code class="scala">scala> val threes = for (i <- 1 to 20 if i % 3 == 0) yield i
threes: scala.collection.immutable.IndexedSeq[Int] = Vector(3, 6, 9, 12, 15, 18) </code></pre>
									

					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Exercise:</strong></p>
						<p style="text-align: left">Given a double <strong >amount</strong > , write an expression to return “greater” if it is more than zero, “same” if it equals zero, and “less” if it is less than zero. Can you write this with if..else blocks? How about with match expressions?</p>
					</section>
					<section>
						<h2 id="expression">Expressions</h2>					
						<p><strong>Exercise: Solution</strong></p>
						<p style="text-align: left">Given a double <strong >amount</strong > , write an expression to return “greater” if it is more than zero, “same” if it equals zero, and “less” if it is less than zero. Can you write this with if..else blocks? How about with match expressions?</p>
						<pre><code class="scala">scala> val amount = 1.1
scala> if (amount > 0) "greater" else if (amount < 0) "less" else "same"
res0: String = greater</code></pre> 	
						<pre><code class="scala">scala> amount match {
case x if x > 0 => "greater"
case x if x < 0 => "lesser"
case x => "same"
}
res1: String = greater</code></pre> 					
					</section>
				</section>
				<section>
					<section>
					<h2 id="functions">Functions</h2>
					<li style="text-align: left"><strong>Functional programming languages</strong> are geared to support the creation of highly reusable and composable functions.</li>
					<li style="text-align: left">A simple function (e.g., to double a number) may be picked up and applied
across a 50,000-node list, or given to an actor to be executed either locally or in a remote server.</li>
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p><strong>Syntax:</strong> </p>
					<pre><code class="scala">def &lt;identifier&gt;(&lt;identifier&gt;: &lt;type&gt;[, ... ]): &lt;type&gt; = &lt;expression&gt;</code></pre>
					<p><strong>Example:</strong> Function that performs an multiplication</p>
					<pre><code class="scala">scala> def multiplier(x: Int, y: Int): Int = { x * y }
multiplier: (x: Int, y: Int)Int
scala> multiplier(6, 7)
res0: Int = 42 </code></pre>
					
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p><strong>Recursive Functions:</strong> </p>
					<p style="text-align: left" ><strong>Definition:</strong> A function that may invoke itself, preferably with some type of parameter or external condition that will be checked to avoid an infinite loop</p>
					<p style="text-align: left" ><strong>Example:</strong> A recursive function that raises an integer by a given positive exponent:</p>
					<pre><code class="scala">scala> def power(x: Int, n: Int): Long = {
if (n >= 1) x * power(x, n-1)
else 1
}
power: (x: Int, n: Int)Long
scala> power(2, 8)
res6: Long = 256</code></pre>
					
					</section>
					<section>
						<h2 id="functions">Functions</h2>					
						<p><strong>Exercise:</strong></p>
						<p style="text-align: left">Write a function that computes the area of a circle given its radius.</p>
					</section>
					<section>
						<h2 id="functions">Functions</h2>					
						<p><strong>Exercise: Solution</strong></p>
						<p style="text-align: left">Write a function that computes the area of a circle given its radius.</p>
						<pre><code class="scala">scala> def area(r:Double) = r * r * 3.14159</code></pre>
						<p> Or:</p>
						<pre><code class="scala">scala> import scala.math._
scala> def area(r:Double) = Pi*pow(r,2)
</code></pre>						
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p><strong>Partially Applied Functions and Currying</strong> </p>
					<p>Example of Partialy Applied Function </p>
					<pre><code class="scala">scala> def factorOf(x: Int, y: Int) = y % x == 0
factorOf: (x: Int, y: Int)Boolean</code></pre>
					<pre><code class="scala">scala> val multipleOf3 = factorOf(3, _: Int)
multipleOf3: Int => Boolean = &lt;function1&gt;
scala> val y = multipleOf3(78)
y: Boolean = true</code></pre>
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p><strong>Partially Applied Functions and Currying</strong> </p>
					<p>Example of Currying</p>
<p style="text-align: left">Instead of breaking up a parameter list into applied and unapplied parameters, apply the parameters for one list while leaving another list unapplied.</p>
					<pre><code class="scala">scala> def factorOf(x: Int)(y: Int) = y % x == 0
factorOf: (x: Int)(y: Int)Boolean</code></pre>
					<pre><code class="scala">scala> val multipleOf3 = factorOf(3) _
multipleOf3: Int => Boolean = &lt;function1&gt;
scala> val y = multipleOf3(78)
y: Boolean = true</code></pre>
					
					</section>
					<section>
					<h2 id="functions">Functions</h2>
					<p>Exercise:</p>
					<p style="text-align: left"> Write a function literal that takes two integers and returns the higher number.</p>
					<p style="text-align: left">Then write a higher-order function that takes a 3-sized tuple of integers plus this function literal, and uses it to return the maximum value in the tuple.</p>
					</section>

					<section>
					<h2 id="functions">Functions</h2>
					<p>Result:</p>
					<p style="text-align: left"> Write a function literal that takes two integers and returns the higher number. Then
write a higher-order function that takes a 3-sized tuple of integers plus this function
literal, and uses it to return the maximum value in the tuple.</p>
						<pre><code>scala> val max = (x: Int, y: Int) => if (x > y) x else y
max: (Int, Int) => Int = &lt;function2&gt;

scala> max(23, 32)
res0: Int = 32</code></pre>

<pre><code>scala> def pickOne(t: (Int, Int, Int), cmp: (Int, Int) => Int): Int = {
cmp(t._1, cmp(t._2, t._3))
}
pickOne: (t: (Int, Int, Int), cmp: (Int, Int) => Int)Int

scala> pickOne( (14, 7, 9), max )
res1: Int = 14</code></pre>
					</section>
					


				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
